
// OPTIX Prototype - simplified 2D simulation (grid-based)
// Author: generated by ChatGPT for user demo
// 간단한 셀 기반 맵, A* 경로탐색, 에이전트 이동, KPI 계산 구현

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const gridSize = 20; // grid cell pixel size
const cols = Math.floor(canvas.width / gridSize);
const rows = Math.floor(canvas.height / gridSize);

let layout = null;
let nodes = [];
let agent = null;
let running = false;
let speed = 5; // slider 1..10
let simStart = null;

// KPI
let totalDistance = 0;
let totalTime = 0;
let count = 0;
let lastTimestamp = 0;

// Sample layouts embedded fallback (also provided in layout.json)
const sampleLayouts = {
  before: {
    name: "기본 레이아웃 (설비 도입 전)",
    cols: cols, rows: rows,
    // obstacles: array of {x,y,w,h} in grid coords
    obstacles: [
      {x:6,y:2,w:2,h:14}, {x:10,y:6,w:2,h:12}, {x:14,y:2,w:2,h:14},
      {x:18,y:6,w:2,h:12}
    ],
    pickup: {x:2,y:4},
    drop: {x:36,y:20}
  },
  after: {
    name: "개선 레이아웃 (설비 도입 후)",
    cols: cols, rows: rows,
    obstacles: [
      {x:8,y:2,w:2,h:8}, {x:12,y:12,w:2,h:10}, {x:20,y:2,w:2,h:8}
    ],
    pickup: {x:2,y:4},
    drop: {x:36,y:20}
  }
};

function resetKPI(){
  totalDistance = 0; totalTime = 0; count = 0;
  document.getElementById('k_distance').innerText = 0;
  document.getElementById('k_time').innerText = 0;
  document.getElementById('k_count').innerText = 0;
  document.getElementById('report').innerHTML = '';
}

function createGrid(){
  nodes = [];
  for(let y=0;y<rows;y++){
    let row = [];
    for(let x=0;x<cols;x++){
      row.push({x,y,walkable:true, f:0,g:0,h:0, parent:null});
    }
    nodes.push(row);
  }
}

function applyObstacles(obstacles){
  obstacles.forEach(ob=>{
    for(let yy=ob.y; yy<ob.y+ob.h; yy++){
      for(let xx=ob.x; xx<ob.x+ob.w; xx++){
        if(nodes[yy] && nodes[yy][xx]) nodes[yy][xx].walkable = false;
      }
    }
  });
}

// A* implementation on grid
function heuristic(a,b){ return Math.abs(a.x-b.x) + Math.abs(a.y-b.y); }

function findPath(start, end){
  // start/end are grid coords {x,y}
  const open = [];
  const closed = new Set();
  const key = (n)=>`${n.x},${n.y}`;
  // reset
  for(let r of nodes) for(let n of r){ n.g=0; n.f=0; n.h=0; n.parent=null; }
  const startNode = nodes[start.y][start.x];
  const endNode = nodes[end.y][end.x];
  if(!startNode.walkable || !endNode.walkable) return null;
  open.push(startNode);
  while(open.length){
    // pick lowest f
    open.sort((a,b)=>a.f-b.f);
    const current = open.shift();
    closed.add(key(current));
    if(current === endNode){
      // reconstruct path
      const path=[];
      let cur = current;
      while(cur){ path.push({x:cur.x,y:cur.y}); cur = cur.parent; }
      return path.reverse();
    }
    // neighbors 4-dir
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(let d of dirs){
      const nx = current.x + d[0], ny = current.y + d[1];
      if(ny<0||ny>=rows||nx<0||nx>=cols) continue;
      const neighbor = nodes[ny][nx];
      if(!neighbor.walkable) continue;
      if(closed.has(key(neighbor))) continue;
      const tentativeG = current.g + 1;
      const inOpen = open.includes(neighbor);
      if(!inOpen || tentativeG < neighbor.g){
        neighbor.parent = current;
        neighbor.g = tentativeG;
        neighbor.h = heuristic(neighbor, endNode);
        neighbor.f = neighbor.g + neighbor.h;
        if(!inOpen) open.push(neighbor);
      }
    }
  }
  return null; // no path
}

// draw grid
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // grid
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const n = nodes[y][x];
      const px = x*gridSize, py = y*gridSize;
      if(!n.walkable){
        ctx.fillStyle = '#8fa3c8'; ctx.fillRect(px,py,gridSize,gridSize);
      }
      ctx.strokeStyle = '#cfdaf0'; ctx.strokeRect(px,py,gridSize,gridSize);
    }
  }
  // pickup/drop
  if(layout){
    ctx.fillStyle = '#2dbe60';
    ctx.fillRect(layout.pickup.x*gridSize +4, layout.pickup.y*gridSize +4, gridSize-8, gridSize-8);
    ctx.fillStyle = '#ff5c5c';
    ctx.fillRect(layout.drop.x*gridSize +4, layout.drop.y*gridSize +4, gridSize-8, gridSize-8);
  }
  // agent
  if(agent){
    ctx.fillStyle = '#ffcf00';
    ctx.beginPath();
    ctx.arc(agent.x*gridSize + gridSize/2, agent.y*gridSize + gridSize/2, gridSize/2 -3, 0, Math.PI*2);
    ctx.fill();
  }
}

// agent move along path (path is array of grid coords)
function stepAgent(delta){
  if(!agent || !agent.path || agent.pathIndex >= agent.path.length) return;
  const target = agent.path[agent.pathIndex];
  // movement per tick depending on speed
  agent.timer += delta * (speed/5); // speed scale
  if(agent.timer >= agent.interval){
    // move to next cell
    const prev = {x: agent.x, y: agent.y};
    agent.x = target.x; agent.y = target.y;
    agent.pathIndex++;
    agent.timer = 0;
    totalDistance += 1; // one cell = 1 unit distance (simplified)
    document.getElementById('k_distance').innerText = totalDistance;
    // if reached end of path and finished pickup+drop sequence
    if(agent.pathIndex >= agent.path.length){
      // increase count and if more tasks queued, start next
      count += 1;
      document.getElementById('k_count').innerText = count;
      // end time update
      const now = performance.now();
      totalTime = Math.floor((now - simStart)/1000);
      document.getElementById('k_time').innerText = totalTime;
      // stop simulation after one task for demo, or loop to do multiple tasks
      running = false;
      showReport();
    }
  }
}

function showReport(){
  const rep = document.getElementById('report');
  rep.innerHTML = `<strong>시뮬레이션 결과</strong>
    <div>총 이동거리: ${totalDistance} (cell)</div>
    <div>총 처리시간: ${totalTime} s</div>
    <div>처리 건수: ${count}</div>`;
}

function loadLayout(scenario){
  resetKPI();
  createGrid();
  layout = sampleLayouts[scenario] || sampleLayouts.before;
  applyObstacles(layout.obstacles);
  // create agent at pickup
  agent = {
    x: layout.pickup.x, y: layout.pickup.y,
    path: [], pathIndex:0, timer:0, interval:250 // ms per step base
  };
  draw();
}

function startSim(){
  if(!layout) loadLayout(document.getElementById('scenario').value);
  // compute path: pickup -> drop (already at pickup)
  const p = {x: agent.x, y: agent.y};
  const d = layout.drop;
  const path = findPath(p,d);
  if(!path){ alert('경로를 찾을 수 없습니다. 레이아웃을 확인하세요.'); return; }
  agent.path = path.slice(1); agent.pathIndex = 0; agent.timer = 0;
  running = true;
  simStart = performance.now();
  lastTimestamp = performance.now();
  requestAnimationFrame(loop);
}

function loop(ts){
  if(!running) return;
  const delta = ts - lastTimestamp;
  lastTimestamp = ts;
  stepAgent(delta);
  draw();
  requestAnimationFrame(loop);
}

// UI hooks
document.getElementById('loadBtn').addEventListener('click', ()=>{
  const s = document.getElementById('scenario').value;
  loadLayout(s);
});
document.getElementById('startBtn').addEventListener('click', ()=>{
  startSim();
});
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  running = false;
});
document.getElementById('speed').addEventListener('input', (e)=>{
  speed = Number(e.target.value);
});

// auto load default
loadLayout('before');
